---
layout: post
title: Web-Based Lightweight Card Selector
date: '2008-05-31T17:08:00.008-05:00'
author: rammic
tags:
- lightweight
- web-based
- cardspace client
- infocard
- card selector
modified_time: '2008-05-31T18:26:17.974-05:00'
thumbnail: http://bp3.blogger.com/_wC5IWJgdgwA/SEHYyz5xRaI/AAAAAAAAChY/1NDyJBobkJw/s72-c/WebCardUse.jpg
blogger_id: tag:blogger.com,1999:blog-6180833599810788176.post-4329220791308555822
blogger_orig_url: http://blog.rammic.com/2008/05/web-based-lightweight-card-selector.html
---

<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp3.blogger.com/_wC5IWJgdgwA/SEHYyz5xRaI/AAAAAAAAChY/1NDyJBobkJw/s1600-h/WebCardUse.jpg"><img style="float:left; margin:0 10px 10px 0;cursor:pointer; cursor:hand;" src="http://bp3.blogger.com/_wC5IWJgdgwA/SEHYyz5xRaI/AAAAAAAAChY/1NDyJBobkJw/s200/WebCardUse.jpg" border="0" alt="" id="BLOGGER_PHOTO_ID_5206681011654575522" /></a><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp0.blogger.com/_wC5IWJgdgwA/SEHYzD5xRbI/AAAAAAAAChg/OYemplq-kQk/s1600-h/WebCardProvisioning.jpg"></a></span></span><span class="Apple-style-span" style="white-space: pre-wrap; "><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Something we've been working on is the ability to create a web-based card selector which will work in situations where a full card selector is not available or appropriate. Since selectors are not yet ubiquitous and inappropriate in many tactical situations, we are working on using a HTML5 based approach to enable an Infocard/CardSpace-based enterprise to work with standard web browsers.</span></span></span><div><span class="Apple-style-span" style="white-space: pre-wrap; "><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"> The major changes in HTML5 which allow for this to occur are offline caching (HTML Manifest),  the navigator.registerProtocolHandler action, and the DOM/Session storage capabilities. For more information, see </span></span><a href="http://starkravingfinkle.org/blog/2008/05/firefox-3-offline-app-demo-part-2/"><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Mark Finkle</span></span></a><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">'s excellent blog on Firefox 3's offline features and the</span></span><a href="http://www.whatwg.org/specs/web-apps/current-work/"><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"> WHATWG HTML5 Draft Specification</span></span></a><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"> for the rest. With these capabilities to be included in future web browsers, we can now assume that the client browser:</span></span></span><div><ul><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Can cache URL resources and seamlessly serve them when connectivity to the IDP cannot be established<br /></span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Can route particular protocol requests from arbitrary RP's to a registered IDP web app<br /></span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Can (persistently) store a user's preferences and settings locally, where information regarding trust and disclosures can be held.<br /></span></span></li></ul><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">With these capabilities, one can begin to see how a web app could operate as a client card selector:</span></span></div><div><ol><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">The user accesses an IDP provisioning site, where the card selector resources (HTML, Javascripts, etc) can be retrieved for later use and registered to handle a target protocol such as "infocard://" (perhaps even "openid://"?). At this point, all required Card metadata would be retrieved and stored.</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">After provisioning occurs, the user access an RP with a login link which specifies the target protocol and any parameters needed for login, e.g. infocard://respondToUrl=[rpurl]&amp;requiredClaims=[claims]&amp;optionalClaims=[claims]</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">The browser prompts the user to select a registered webapp to handle the invocation, which roughly parallels card selection. Upon selection of the IDP offline app registered in step 1, the browser redirects the user to the cached application. (Note that per the WHATWG draft specification, no information necessarily goes back to the IDP at this point)</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">The cached web app parses the URL encoded information provided in step two and previews the requested claims to the user. This is analogous to the pre-retrieval step of the Infocard ceremony. The user may select/deselect optional attributes or cancel the transaction at this point.</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">If the user chooses to continue, the cached Javascript preforms a AJAX WS-Trust RST to the IDP's endpoint specified during provisioning.</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">The IDP responds with an RSTR which the cached Javascript parses, displaying the display token to the user (for verification) and the security token into an embedded form with the RP's respondToUrl as the action.</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">After review, the user chooses to submit the token, which is posted to the RP site in the same fashion as current card selectors (HTTP POST with a xmlToken value).</span></span></li></ol><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">This approach seemingly solves the problem of a lack of card selectors and lightweight clients assuming that all major browser implement HTML5 (which appears to be the case). The above approach actually works as demonstrated by our proof of concept which uses only Firefox 3 or any browser with Google Gears.Â </span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><br /></span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">The registerProtocolHandler (and possibly even the MIME handler) seem to have a number of possibilities within the federated identity communities. As demonstrated above with the Infocard scenario, this can address the vexing "Where are you from?" problem which plagues web-based federated identity solutions including OpenID. Omitting the RP from the redirection phase via the web app selector and a carefully crafted offline web app should do wonders to reduce spoofability and increase usability.</span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><br /></span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">While this is a big step to lightweight identity selectors, it does lack a number of the nice features available in a full card selector:</span></span></div><div><ul><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Cannot provide "clues" regarding the applicability of registered web apps (such as disabling cards/webapps which are inappropriate for the required claims)<br /></span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Cannot easily integrate with the OS for things such as public/private key creation, thus this is clearly aimed toward managed card with browser-friendly authentication.</span></span></li><li><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Encryption in Javascript is hard. XMLEnc with the RP's certificate isn't possible with this approach, so we have to depend upon Audit mode or unencrypted tokens over HTTPS.</span></span></li></ul><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><br /></span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">Below is a simple web-based card selector provisioning data flow, though I forgot to put in the card metadata exchange in step 4.Â </span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><br /></span></span></div><div style="text-align: center;"><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><img src="http://lh3.ggpht.com/rammic/SEHYzD5xRbI/AAAAAAAAChg/J00rNPTWfhA/WebCardProvisioning.jpg" width="400px" /><br /></span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;"><br /></span></span></div><div><span class="Apple-style-span"  style="font-family:'lucida grande';"><span class="Apple-style-span"  style="font-size:small;">The offline cache is much more useful than just for the protection of the user privacy; once offline tokens within Infocard become possible, this approach should still be very viable. I have a screencast of our demo and I'll update this post when I get around to uploading it to YouTube.Â </span></span></div></div></div></div></div>